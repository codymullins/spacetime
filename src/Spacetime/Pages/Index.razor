@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@page "/"
@using Spacetime.Blazor.Sortable
@using Spacetime.Core
@using Spacetime.Core.Services
@using Spacetime.Core.Infrastructure;
@using Spacetime.Shared.Components
@using Spacetime.Shared.Components.Display
@using Spacetime.Shared.Components.Inputs
@using Spacetime.Shared.Components.Typography
@using Spacetime.Store.Requests
@inject Sortable Sortable
@inject IState<RequestState> RequestState
@inject IDispatcher Dispatcher
@inject IDialogService DialogService
@inject ILogger<Index> Log

<style>
    /* need to figure out the best way to further customize mud blazor */
    /* customization seems to be the biggest issue to mud as opposed to using tailwind :-( */
    .mud-list-item-text .mud-typography {
        display: flex
    }
</style>
<div class="grid gap-1 grid-cols-12 flex grow">
    <div class="border-r border-solid col-span-3" style="@($"border-color:{Theme.Swatch.Divider}")">
        @if (RequestState.Value.FilteredRequests == null)
        {
            <p><em>Loading...</em></p>
        }
        else
        {
            <div class="px-2 pb-2 flex justify-between">
                <MudTextField @bind-Value="SearchText"
                          DebounceInterval="100"
                          OnDebounceIntervalElapsed="OnFilter"
                          Margin="Margin.Dense"
                          Variant="Variant.Outlined"
                          Placeholder="Filter requests" />
                <MudButton OnClick=@NewRequest><MudIcon Icon="@Icons.Filled.AddCircleOutline" /></MudButton>
            </div>
            @if (!RequestState.Value.FilteredRequests.Any())
            {
                <MudPaper>
                    <MudList Clickable="true" Dense="true">
                        <MudListItem>No requests</MudListItem>
                    </MudList>
                </MudPaper>
            }
            @if (RequestState.Value.FilteredRequests.Any())
            {
                <MudPaper>
                    <MudList Clickable="true" Dense="true" SelectedValueChanged="OnSelectedValueChanged">
                        @foreach (var req in RequestState.Value.FilteredRequests)
                        {
                            <MudListItem Class="flex" Value="@req.Id">
                                <span style="width: 40px"><SmallCaps>@GetRequestPrefix(req)</SmallCaps></span>
                                <span>
                                    @req.Name
                                </span>
                            </MudListItem>
                        }
                    </MudList>
                </MudPaper>
            }
        }
    </div>
    <div class="col-span-9 flex flex-col">
        @if (RequestState.Value.SelectedRequest?.Type == SpacetimeType.REST)
        {
            <RestView Request="@RequestState.Value.SelectedRequest" OnDelete="ConfirmDelete" />
        }
        else if (RequestState.Value.SelectedRequest?.Type == SpacetimeType.gRPC)
        {
            <GrpcView Request="@RequestState.Value.SelectedRequest" />
        }
        else
        {
            <div class="mx-4 my-4">Select a request or create a new one to get started.</div>
        }
    </div>
</div>
@code {
    public string SearchText { get; set; }
    private List<string> RequestDropdown { get => new List<string> { "Delete" }; }
    private List<SpacetimeRequest> Requests { get; set; }
    private List<SortableListItem> Items => Requests != null
    ? Requests.Select(p => new SortableListItem { Id = p.Id, Value = p.Name, Prefix = GetRequestPrefix(p) }).ToList()
    : new List<SortableListItem>();

    private ElementReference _ref { get; set; }

    protected override Task OnInitializedAsync()
    {
        Dispatcher.Dispatch(new FetchRequestsAction());
        return Task.CompletedTask;
    }

    public void OnFilter()
    {
        Dispatcher.Dispatch(new FilterRequestsAction(SearchText));
    }

    public void OnSelectedValueChanged(object data)
    {
        var id = data as int?;

        if (id.HasValue)
        {
            Log.LogInformation($"Selected request {id}");
            Dispatcher.Dispatch(new ShowRequestAction(id.Value));
        }
    }

    public async Task ConfirmDelete(SpacetimeRequest request)
    {
        var parameters = new DialogParameters();
        parameters.Add("ContentText", "Do you really want to delete this request? This process cannot be undone.");
        parameters.Add("ButtonText", "Delete");
        parameters.Add("Color", Color.Error);

        var options = new DialogOptions() { CloseButton = true, MaxWidth = MaxWidth.ExtraSmall };

        var dialog = DialogService.Show<Dialog>("Delete", parameters, options);
        var result = await dialog.Result;
        if (!result.Cancelled)
        {
            Dispatcher.Dispatch(new DeleteRequestAction(request.Id));
        }
    }

    private string GetRequestPrefix(SpacetimeRequest req)
    {
        var str = string.Empty;

        if (req == null)
        {
            return str;
        }

        switch (req.Type)
        {
            case SpacetimeType.REST:
                str = req.Method;
                break;
            case SpacetimeType.gRPC:
                str = "gRPC";
                break;
            default:
                str = req.Method;
                break;
        }

        return str;
    }

    private async Task NewRequest()
    {
        var options = new DialogOptions() { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<NewRequestModal>("New Request", options);
        var result = await dialog.Result;
        if (!result.Cancelled)
        {
            var data = result.Data as NewRequestModal.NewRequestModalResult;
            var req = new SpacetimeRequest();
            req.Name = string.IsNullOrWhiteSpace(data.RequestName) ? "New Request" : data.RequestName;
            req.Type = data.Type;
            req.Method = "GET";
            Dispatcher.Dispatch(new AddRequestAction(req));
        }
    }

    private void Save(SpacetimeRequest request)
    {
        Dispatcher.Dispatch(new UpdateRequestAction(request));
    }
}